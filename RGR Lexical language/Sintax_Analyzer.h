#pragma once
#include <iostream>
using namespace std; 
#include <list>
#include <unordered_map>
#include <algorithm>
#include "Lexical_Analyzer.h"

// Класс Sintax реализует синтаксический анализатор на основе лексического анализатора
class Sintax : protected TableToken
{
protected:

	// Список ключевых слов грамматики
	const vector<string> Keywords
	{
		"[eps]", "[V]", "[C]", "[rel]", "[rem]", "[L]"
	};

	// Структура для хранения элемента канонической таблицы LR-анализатора
	struct canonical_table
	{
		string nonterminal;    // Нетерминал
		int dot;               // Позиция точки в правиле
		vector<string> rule;     // Правило (список символов)
		vector<string> following;// Множество следующих символов (lookahead)
		int number_table;		 // Номер таблицы в которой она находится

		bool operator==(const canonical_table& other) const
		{
			return nonterminal == other.nonterminal && dot == other.dot && rule == other.rule && following == other.following;
		}
	};

	// Структура для хранения информации о переходах (goto)
	struct for_goto
	{
		int number_table; // Номер таблицы откуда этот символ
		string symbol;    // Символ для переноса

		bool operator==(const for_goto& other) const
		{
			return number_table == other.number_table && symbol == other.symbol;
		}
	};

public:
	// Конструктор, принимает имя файла с грамматикой
	Sintax(string file_name, string start_nonterminal_ = "<S>");

	// Выводит все правила грамматики
	void Print_Rules();

	void Write_Rules(ofstream& file);

	void Write_Canonical_Table(const vector<canonical_table>& can_t, ofstream& file);

	// Выводит список всех нетерминалов
	void Print_Nonterminals();

	void Write_Nonterminals(ofstream& file);

	// Выводит список всех терминалов
	void Print_Terminals();

	void Write_Terminals(ofstream& file);

protected:
	// Карта: нетерминал -> список правил (каждое правило — список строк)
	map <string, vector<vector<string>>> map_rules;

	// Список нетерминалов грамматики
	vector<string> nonterminals;

	// Список терминалов грамматики
	vector<string> terminals;

	// Читает правила из файла и заполняет map_rules, nonterminals, terminals
	void Rule_to_code(fstream& file);

	// Удаляет дубликаты eps в map_rules
	void Remove_Duplicate_Eps();

	// Сообщает об ошибке в правиле и завершает выполнение
	void Rule_Error(string error_text, fstream& file);

	// Сообщает об ошибке и завершает выполнение
	void Error(string error_text);

	// Находит все нетерминалы в файле
	void Find_Nonterminals(fstream& file);

	// Создаёт вспомогательные таблицы для синтаксического анализа
	vector<vector<canonical_table>> Create_Tables(string start_nonterminal_ = "<S>");

	// Вычисляет множество FIRST для нетерминала (или терминала)
	vector<vector<string>> FIRST_One(string nonterminal, set<string> visited);

	// Вычисляет множество FIRST для следующего элемента после текущего в правиле
	vector<vector<string>> FIRST_One_for_next(const vector<string>::const_iterator it, const vector<string>& r);

	void Print_Firsts(vector<vector<vector<string>>> f);

	// Декартово произведение двух списков списков строк
	vector<vector<string>> Cartesian_Product(vector<vector<string>> to, vector<vector<string>> from);

	// Обрезает каждый список в from до длины n
	vector<vector<string>> Clipping(int n, vector<vector<string>> from);

	// Проверяет, является ли строка нетерминалом
	bool IsNonterminal(string s);

	// Проверяет, является ли строка терминалом
	bool IsTerminal(string s);

	// Проверяет, является ли строка ключевым словом
	bool IsKeyword(string s);



	// Система канонических таблиц для синтаксического анализа
	vector<vector<canonical_table>> canonical_table_system;



	// Формирует стартовую таблицу для синтаксического анализа
	vector<canonical_table> Start_Table(string start_nonterminal);

	vector<Sintax::for_goto> Find_All_Goto(const vector<canonical_table>& can_t);

	Sintax::for_goto Find_One_Goto(const canonical_table& can_t);

	void Print_Canonical_Table(const vector<canonical_table>& can_t);

	vector<canonical_table>GOTO(const for_goto& args, const vector<canonical_table>& can_t, int number_table);
};